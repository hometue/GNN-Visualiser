import AddIcon from '@mui/icons-material/Add';
import RemoveIcon from '@mui/icons-material/Remove';
import HelpIcon from '@mui/icons-material/Help';
import { Box, Button, Card, CardContent, Dialog, IconButton, Typography } from "@mui/material";
import { CSSProperties, MouseEvent, useState } from "react";
import { ReadWrite } from "../types/readWrite";
import { Graph } from "./graph";
import ValueViewEdit from './ValueViewEdit';

function NodeRowView(props: {row: number[], updateGraph: (target: number, value: number) => void, selected: boolean}) {
	const [hover, setHover] = useState(false);
	const hoverStyle = {backgroundColor: "WhiteSmoke"};
	const normalStyle = {backgroundColor: "white"};
	let style: CSSProperties = {};
	if(hover || props.selected){
		style = hoverStyle;
	}
	else{
		style = normalStyle
	}

	const changeStyleOnMouseOver = (e: MouseEvent<HTMLDivElement>) => { 
		setHover(true);
	};

	const changeStyleOnMouseleave = (e: MouseEvent<HTMLDivElement>) => { 
		setHover(false);
	};

	const updateValue = (target: number) => {
		return (value: number) => {
			if(value === 0){
				props.updateGraph(target, 0);
			}
			else{
				props.updateGraph(target, 1);
			}
		}
	}

	return(
		<>
			{props.row.map((value, index)=> {
				return (
					<td key={index} style={{ borderStyle: "solid", borderWidth: "1px", padding: 0 }}>
						<span style={style} onMouseLeave={changeStyleOnMouseleave} onMouseOver={changeStyleOnMouseOver}>
							<ValueViewEdit value={value} updateGraph={updateValue(index)}/>
						</span>
					</td>
				)
		})}</>
	)
}

function NodeFeatures(props: {nodeFeatures: ReadWrite<number[]>}){
	const writeNodeFeature = (index: number) => {
		return (newNodeFeature: number) => {
			const newNodeFeatures = [...props.nodeFeatures.data];
			newNodeFeatures[index] = newNodeFeature;
			props.nodeFeatures.setData(newNodeFeatures)
		}
	}
	return (
		<Box>
			<div>Node embedding. Click to edit.</div>
			{props.nodeFeatures.data.map((value, index)=>{
				return (
					<span key={index} style={{ borderStyle: "solid", borderWidth: "1px" }}>
						<ValueViewEdit value={value} updateGraph={writeNodeFeature(index)} />
					</span>
				)
			})}
		</Box>
	)
}

export default function AdjGraphView(props: {graph: ReadWrite<Graph>}) {
	const [helpOpen, setHelpOpen] = useState(false);
	const writeGraph = (src: number) => {
		return (target: number, value: number) => {
			const newGraph = props.graph.data.cloneGraph();
			newGraph.adjMatrix[src][target] = value
			props.graph.setData(newGraph);
		}
	}

	const updateNodeFeatures = (newNodeFeatures: number[]) => {
		const newGraph = props.graph.data.cloneGraph();
		newGraph.nodeFeatures = newNodeFeatures;
		props.graph.setData(newGraph);
	}

	return (
		<>
			<Card style={{display: 'inline-block'}} variant="outlined">
				<CardContent>
					<Button onClick={() => {setHelpOpen(true)}} startIcon={<HelpIcon />}>Help</Button>
					<div>Adj matrix. Edit by clicking on the value then pressing enter or clicking away. Only 0 or 1 are valid inputs, any other input is set to 1.</div>
					<Box>
						<Button onClick={() => {
							const newGraph = props.graph.data.cloneGraph();
							newGraph.removeNode(newGraph.adjMatrix.length - 1);
							props.graph.setData(newGraph);
						}}
						startIcon={<RemoveIcon fontSize="small" />}>
							Remove node
						</Button>
						<Button onClick={() => {
							const newGraph = props.graph.data.cloneGraph();
							newGraph.addNode();
							props.graph.setData(newGraph);
						}}
						startIcon={<AddIcon fontSize="small" />}>
							Add node
						</Button>
					</Box>
					<Box width="fit-content">
						<table style={{borderSpacing: "0px"}}><tbody>
						{props.graph.data.adjMatrix.map((row, index) => {
							return (
							<tr key={index}>
								<td style={{ borderStyle: "solid", borderWidth: "1px", padding: 0 }}>Node {index}: </td>
								<NodeRowView row={row} updateGraph={writeGraph(index)} selected={index===props.graph.data.selectedNode} />
							</tr>
							)
							
						})}
						</tbody></table>
					</Box>
					<NodeFeatures nodeFeatures={{data: props.graph.data.nodeFeatures, setData: updateNodeFeatures}} />
				</CardContent>
			</Card>
			<Dialog open={helpOpen}>
				<Box sx={{padding: 5}}><Typography>
					You are looking at a playground for a Graph Neural Network. It is a neural network that takes an input graph and creates an output graph.<br />
					Each node of the graph has a node feature, the job of the Graph Neural Network is to calculate the final embedding by gathering data from other nodes.

					Each layer is made up of a messaging function and an aggregate function. The messaging function creates a message from either the feature of the node or the embedding generated by the previous layer. Each node sends their neighbours their message.<br />
					The messaging function used in this playground is: Message = weight * node feature + bias.<br/>
					The aggregate function then gathers the messages and applies a function on it. In this playground, the mean function is used as the default aggregate function but it can be changed. The new embedding is the aggregate of all messages.
				</Typography></Box>
				<Button onClick={() => {setHelpOpen(false)}}>Close</Button>
			</Dialog>
		</>
	)
}